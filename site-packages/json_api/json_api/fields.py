import datetime
from functools import cached_property
from typing import Any
from typing import List as List_
from typing import Sequence
from typing import Set as Set_

from .conditions import AnyValue, In, MultipleOf
from .logic_opt import AllOf


class BaseField():
    _type = ''
    _default: Any = None

    def __init__(self, required=True, nullable=False, condition=None, default=None):
        self._is_empty = False
        self._required = required if not default else False
        self._nullable = nullable
        self._condition = condition if condition else AnyValue()
        self._default = default if default else self._default
        self._extra_validator = None

    @cached_property
    def schema(self):
        result = {'type': self._type if not self._nullable else [self._type, None]}
        if not self._required:
            try:
                result.update({'default': self._default()})
            except ValueError:
                result.update({'default': self._default})
        return self._condition.gen_schema(field_type=self._type, schema=result)

    def data_wrapper(self, data):
        return data

    def extra_validator(self):
        def wrapper(f):
            self._extra_validator = f
            return f


class Boolean(BaseField):
    _type = 'boolean'
    _default = None


class String(BaseField):
    _type = 'string'
    _default = ''


class Enum(String):
    def __init__(self, enum_class, required=True, nullable=False, condition=None, default=None):
        self._enum_class = enum_class
        if default:
            default = default.name
        super().__init__(required=required, nullable=nullable, condition=condition, default=default)

    def data_wrapper(self, data):
        if not data and self.accept_none:
            return None
        return self._enum_class[data]


class Email(String):
    @cached_property
    def schema(self):
        result = super().schema
        result.update({'format': 'email'})
        return result


class DateTime(String):
    @cached_property
    def schema(self):
        result = super().schema
        result.update({'format': 'date-time'})
        return result

    def data_wrapper(self, data):
        return datetime.datetime.fromisoformat(data)


class Date(String):
    @cached_property
    def schema(self):
        result = super().schema
        result.update({'format': 'date'})
        return result

    def data_wrapper(self, data):
        return datetime.date.fromisoformat(data)


class Time(String):
    @cached_property
    def schema(self):
        result = super().schema
        result.update({'format': 'time'})
        return result

    def data_wrapper(self, data):
        return datetime.time.fromisoformat(data)


class Number(BaseField):
    _type = 'number'
    _default = 0.0

    def data_wrapper(self, data):
        return float(data)


class Integer(BaseField):
    _type = 'integer'
    _default = 0

    def data_wrapper(self, data):
        return int(data)


class List(BaseField):
    _type = 'array'
    _default = list

    def __init__(self, sub_field, required=True, nullable=False, condition=None, default=None):
        self._sub_field = sub_field
        super().__init__(required=required, nullable=nullable, condition=condition, default=default)

    @cached_property
    def schema(self):
        result = super().schema
        result.update({'items': self._sub_field.schema})
        return result

    def data_wrapper(self, data):
        result = [self._sub_field.data_wrapper(item) for item in data]
        return super().data_wrapper(result)


class Set(List):
    _default = set

    @cached_property
    def schema(self):
        result = super().schema
        result['uniqueItems'] = True
        return result

    def data_wrapper(self, data):
        return set(super().data_wrapper(data))


class Tuple(BaseField):
    _type = 'array'
    _default = tuple

    def __init__(self, required=True, nullable=False, condition=None, default=None):
        self._fields = _fields
        super().__init__(required=required, nullable=nullable, condition=condition, default=default)

    @cached_property
    def schema(self):
        result = super().schema
        result.update({'items': [field.schema for field in self.fields]})
        return result

    def data_wrapper(self, data):
        result = [self._fields.data_wrapper(item) for item in data]
        return tuple(result)
